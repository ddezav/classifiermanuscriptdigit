# -*- coding: utf-8 -*-
"""ClassifierDigitManuscript.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1AqaWWE7CL-m6KuvwNPXiWVa_beFF4eeb
"""

from math import sqrt

def Euclidean_distance(row1, row2):
  distance = 0
  for i in range(len(row1)-1):
    distance += (row1[i] - row2[i])**2

  return sqrt(distance)

def Get_Neighbors(train, test_row, num):
  distance = list() # []
  data = []
  for i in train:
    dist = Euclidean_distance(test_row, i)
    distance.append(dist)
    data.append(i)
  
  distance = np.array(distance)
  data = np.array(data)
  #Finding the index in ascending order
  index_dist = distance.argsort()
  #Arranging data according to index
  data = data[index_dist]
  #slicing k value from number of data
  neighbors = data[:num]
 
  return neighbors


def predict_classification(train, test_row, num):
  Neighbors = Get_Neighbors(train, test_row, num)
  Classes = []
  for i in Neighbors:
    Classes.append(i[-1])
    prediction = max(Classes, key= Classes.count)
  return prediction

def accuracy(y_true, y_pred):
  n_correct = 0
  for i in range(len(y_true)):
    if y_true[i] == y_pred[i]:
      n_correct += 1
    acc = n_correct/len(y_true)
  return acc

from sklearn.datasets import fetch_openml, load_digits
from keras.datasets import mnist
import numpy as np
import pandas as pd 
import matplotlib.pyplot as plt
import matplotlib

#mnist = fetch_openml("mnist_784") 
#load_digits()
(train_X, train_y), (test_X, test_y) = mnist.load_data()

# checking the column names and preprocessing target values in standard format
#mnist.keys()
#mnist.target = mnist.target.astype(np.int8)

#Determining independent and dependent variable and finding the shape
x = np.array(train_X)
x = x.reshape(len(x),784)
y = np.array(train_y)

print(x.shape, y.shape)
#output ((70000, 784), (70000,))
# shuffling the values of x and y
si = np.random.permutation(x.shape[0])
x = x[si]
y = y[si]

some_digit = x[12]
some_digit_image = some_digit.reshape(28, 28)

plt.imshow(some_digit_image, cmap=matplotlib.cm.binary)
plt.axis("off")
plt.show()

#slicing data
trainx = x
trainy = y
#Inserting trainy in trainx
train = np.insert(trainx, 784, trainy, axis = 1)
prediction = predict_classification(train, train[1244], 4)
prediction
#Output 8.0

train[1244][-1]

#Plotting the output
some_digit = train[1244][:-1]
some_digit_image = some_digit.reshape(28, 28)
plt.imshow(some_digit_image, cmap=matplotlib.cm.binary)
#plt.imshow(some_digit_image, cmap=plt.get_cmap('gray'))

plt.axis("off")
plt.show()

#test_X, test_y are used to evaluate accuracy
y_pred=[]
y_true=test_y

eval_X = np.array(test_X)
eval_X = eval_X.reshape(len(eval_X),784)

for i in range(len(eval_X)):
  prediction = predict_classification(train, eval_X[i], 4)
  y_pred.append(prediction)
# Accuracy
accuracy(y_true, y_pred)
# Output 0.929 (i.e., 92%)